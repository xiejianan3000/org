* TODO [#A] 面试
DEADLINE: <2023-05-25 Sat>


* STARTED LEETCODE 150 - 300 题, 尽可能覆盖题型
DEADLINE: <2023-05-15 Mon>

- [ ] 根据前中后序构建二叉树
- [ ] 将二叉搜索树变平衡

:LOGBOOK:
CLOCK: [2023-05-09 Tue 16:05]--[2023-05-09 Tue 16:44] =>  0:39
CLOCK: [2023-05-09 Tue 15:12]--[2023-05-09 Tue 15:48] =>  0:36
CLOCK: [2023-05-09 Tue 13:33]--[2023-05-09 Tue 14:49] =>  1:16
- [ ] 一个小时从 C 语言中文网或者其他网站搞定这些算法
  - [ ] 图的种类
  - [ ] 图的存储方式
    - [ ] 顺序
    - [ ] 链式
      - [ ] 邻接表
      - [ ] 十字链表
      - [ ] 多重表

CLOCK: [2023-05-09 Tue 11:39]--[2023-05-09 Tue 12:04] =>  0:25
CLOCK: [2023-05-09 Tue 10:45]--[2023-05-09 Tue 11:01] =>  0:16
- [ ] 阅读 剑指 OFFER 字符串 所有题型, 不要做, 列出所有解题方法
  - [ ] 有限状态究
  - [ ] 深度搜索
  - [ ] 动态规划
  - [ ] 递归
  - [ ] 回溯

CLOCK: [2023-05-09 Tue 10:01]--[2023-05-09 Tue 10:24] =>  0:23
- [X] 二叉搜索树删除节点 - 第二次

CLOCK: [2023-05-09 Tue 09:40]--[2023-05-09 Tue 09:50] =>  0:10
- [X]  找二叉搜索树的第 K 小的元素

CLOCK: [2023-05-09 Tue 09:16]--[2023-05-09 Tue 09:35] =>  0:19
- [X] 二叉搜索树迭代器 

CLOCK: [2023-05-09 Tue 09:08]--[2023-05-09 Tue 09:10] =>  0:02
- [X] 二叉搜索树的搜索

CLOCK: [2023-05-09 Tue 08:55]--[2023-05-09 Tue 09:06] =>  0:11
- [X] 二叉搜索树的插入操作

CLOCK: [2023-05-08 Mon 22:45]--[2023-05-09 Tue 00:15] =>  1:30
- [X] 删除树的节点 - 基本逻辑完成, 但是有些 BUG, 导致一些测试用例无法通过
  - [X] 修复删除树节点的 BUG - 主要是递归树的退出条件

CLOCK: [2023-05-08 Mon 19:57]--[2023-05-08 Mon 20:27] =>  0:30
- [X] 设计哈希集合

CLOCK: [2023-05-08 Mon 18:39]--[2023-05-08 Mon 19:06] =>  0:27
- [X] 设计链表

CLOCK: [2023-05-08 Mon 17:34]--[2023-05-08 Mon 18:29] =>  0:55
- [X] 设计循环队列

CLOCK: [2023-05-08 Mon 14:02]--[2023-05-08 Mon 14:20] =>  0:18
- [X] 链表转树或树转链表

CLOCK: [2023-05-08 Mon 13:39]--[2023-05-08 Mon 13:58] =>  0:19
- [X] 数组转树

CLOCK: [2023-05-08 Mon 08:56]--[2023-05-08 Mon 13:33] =>  4:37
- [X] 树的遍历 (包含递归和非递归方法)

CLOCK: [2023-05-07 Sun 21:10]--[2023-05-07 Sun 21:30] =>  0:20
- [X] 数组题的一些经典回顾, 双指针法, 遍历查找, 用哈希表查找或加速缓存
  - [X] 双指针
    - [X] 把两个排序数组移动到同一个数组 
    - [X] 把一个数组的重复的元素删除
  - [X] 查找
    - [X] 直接遍历, 注意 I 的边界条件, 比较繁琐的
      - [X] 查找排序数组的元素个数
    - [X] 哈希法
      - [X] 两数之和

CLOCK: [2023-05-07 Sun 20:48]--[2023-05-07 Sun 21:00] =>  0:12
- [X] 使用这个哈希表把 <环形链表> 这类链表题搞定.

CLOCK: [2023-05-07 Sun 20:06]--[2023-05-07 Sun 20:31] =>  0:25
- [X] 自己用 C 语言实现简易哈希表, 从 Linux 内核中得到的启发

CLOCK: [2023-05-07 Sun 19:21]--[2023-05-07 Sun 19:58] =>  0:37
- [-] 刷了 3 道二分查找的题目

  - [X] 排序数组的插入顺序
  - [X] X 的平方根
  - [ ] 二维数组的交集 

  最后一题, 让我心血来朝, 研究起了 C 语言如何实现哈希表

CLOCK: [2023-05-07 Sun 18:57]--[2023-05-07 Sun 19:18] =>  0:21
- [-] 查找分类:
  - [X] O(N) 查找
  - [-] 二分查找
    - [X] 给定排序好的数组
    - [ ] 二叉树 -  因为数组需要维持一个排序的结果且是连续的存储空间, 插入和删除都很麻烦, 所以二叉树是一种均衡的查找结果, 插入和删除, 查找都很快
  - [X] 哈希表
  
CLOCK: [2023-05-07 Sun 15:38]--[2023-05-07 Sun 16:47] =>  1:09
- [X] 刷了 7 道简单的链表题, 我觉得我可以先把简单难度的链表题刷完, 因为不是很多
  - [X] 倒置链表
  - [X] 快慢指针删除链表重复元素
  - [X] 前后指针删除特定元素, 注意删除头
  - [X] 转换为数组解题
    - [X] 找到链表中间元素
    - [X] 从后面打印
    - [X] 从后面开始遍历, 把用链表表示的二进制转换为 10 进制

:END:


- [X] 使用 C 语言刷题离不了哈希表, 如何快速造一个哈希表成了目前的问题
- [ ] 还是要把快速排序搞好, 因为快速排序很重要
- [ ] 然后是 KMP, 都是很经典的算法
  


* STARTED 数据结构
DEADLINE: <2023-05-08 Sat>

 - [ ] 排序
   - [ ] 选择排序 
   - [ ] 冒泡排序
   - [ ] 插入排序
   - [ ] 希尔排序 
   - [ ] 计数排序
   - [ ] 桶排序
   - [ ] 归并排序
   - [ ] 堆排序
   - [ ] 快速排序

 - [ ] 查找

 - [ ] 树

 - [ ] 图

 - [ ] 匹配子串 KMP 


* TODO 计算机网络
DEADLINE: <2023-05-10 Sat>

* TODO 操作系统
DEADLINE: <2023-05-10 Sat>